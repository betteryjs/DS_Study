
###  `dfs` 二叉树的遍历

#### [从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

```cpp
class Solution {
public:
    // 题目要求的二叉树的 从上至下 打印（即按层打印），
    // 又称为二叉树的 广度优先搜索（BFS）
    vector<int> levelOrder(TreeNode *root) {
        vector<int> ans{};
        if(root== nullptr){
            return ans;
        }
        queue<TreeNode* > queueTree;
        queueTree.push(root);
        while (!queueTree.empty()){
            TreeNode* node = queueTree.front();
            queueTree.pop();
            ans.push_back(node->val);
            if(node->left!= nullptr){
                queueTree.push(node->left);
            }
            if(node->right!= nullptr){
                queueTree.push(node->right);
            }
        }
        return ans;
    }
};
```

#### [从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if(root== nullptr){
            return  vector<vector<int>>{};
        }
        queue<TreeNode* > queueTree;
        queueTree.push(root);
        while (!queueTree.empty()){
            vector<int> tmp;
            for (int i = queueTree.size(); i >0 ; --i) {
                TreeNode* node = queueTree.front();
                queueTree.pop();
                tmp.push_back(node->val);
                if(node->left!= nullptr){
                    queueTree.push(node->left);
                }
                if(node->right!= nullptr){
                    queueTree.push(node->right);
                }
            }
            ans.push_back(tmp);
        }
        return ans;
    }
};
```

#### [从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)


```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode *root) {
        vector<vector<int>> ans;
        if (root == nullptr) {
            return vector<vector<int>>{};
        }
        queue<TreeNode *> queueTree;
        queueTree.push(root);
        while (!queueTree.empty()) {
            vector<int> tmp;
            for (int i = queueTree.size(); i > 0; --i) {
                TreeNode *node = queueTree.front();
                queueTree.pop();
                if(ans.size() % 2 == 0)
                {
                    tmp.push_back(node->val); // 偶数层 -> 队列头部
                }else{
                    tmp.insert(tmp.begin(),node->val);
                }
                if (node->left != nullptr) {
                    queueTree.push(node->left);
                }
                if (node->right != nullptr) {
                    queueTree.push(node->right);
                }
            }
            ans.push_back(tmp);
        }
        return ans;
    }
};

```


### 并查集

```c++
//
// Created by yjs on 2022/6/27.
//


#include <iostream>
#include <vector>

using namespace std;

class UF {
private:

    vector<int> parents;
    int unionCount = 0; // 合并次数



public:


    UF(int capitalSize) {

        parents.resize(capitalSize);
        // init
        for (int i = 0; i < capitalSize; ++i) {
            parents[i] = i;

        }


    }


    int find(int target) {
        if (parents[target] < 0) return target;
        return parents[target] = find(parents[target]);
    }


    int getUnionCount() const {
        return this->unionCount;
    }

    bool unionCapital(int x, int y) {
        // 将 y 合并到 x 集合中
        int findX = find(x);
        int findY = find(y);
        if (findX != findY) {

            parents[findY] = findX;
            unionCount++;
            return true;
        }
        return false;

    }


};


class WeightedQuickUnionUF {
private:

    vector<int> parents;
    int unionCount = 0; // 合并次数
    vector<int> rank; //  保存树的大小




public:


    WeightedQuickUnionUF(int capitalSize) {

        parents.resize(capitalSize);
        // init
        for (int i = 0; i < capitalSize; ++i) {
            parents[i] = i;
            rank[i] = 1;

        }


    }


    int find(int target) {
        if (parents[target] < 0) return target;
        return parents[target] = find(parents[target]);
    }


    int getUnionCount() const {
        return this->unionCount;
    }

    bool unionCapital(int x, int y) {
        // 将 y 合并到 x 集合中
        int findX = find(x);
        int findY = find(y);
        if (findX != findY) {

            if (rank[findX] <= rank[findY]) {
                parents[findY] = findX;

            } else {
                parents[findX] = findY;

            }
            if (rank[findY] == rank[findX]) rank[findY]++;
            unionCount++;
            return true;
        }
        return false;

    }


};


```






